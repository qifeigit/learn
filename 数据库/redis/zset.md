# 操作

\> [zadd order 1 a](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

(integer) 1

\> [zadd order 1 b](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

(integer) 1

\> [zrange order 0 1](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

1) "a"
2) "b"

\> [zadd order 2 c](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

(integer) 1

\> [zrem order a](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

1

\> [zrem order b](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

1

\> [zrange order 0 1](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

1) "c"

\> [zrange order 0 -1](https://try.redis.io/?_ga=2.76738069.1627925657.1621238139-274641180.1604631620#run)

1) "c"



#  为什么要用跳表实现

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。