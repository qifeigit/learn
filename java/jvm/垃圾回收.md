## Gcroot对象

方法区中类的静态属性引用的对象

方法区中常量引用的对象

本地方法
锁对象
栈帧内的局部变量

可使用的工具： mat （memory analysis）


## serial

## serial old

标记压缩

## serial par new

## prallarel scavenage

吞吐量最大

## prallarel old

吞吐量最大

## 


## cms

增量更新



初始标记

重新标记



缺点：

标记清除，会存在碎片

对cpu的资源比较敏感

无法清除浮动垃圾





为什么不用标记压缩？

如果用标记压缩，就无法和用户线程并行




## G1 

注重吞吐量和低延迟

分region，每次会计算回收这个块的价值有多大

老年代达到阈值，进行并发标记???

初始标记
并发标记
最终标记
筛选回收


挑选价值最大的区域

重新标记采用    原始快照

卡表，再对老年代做细分





局部-复制算法，整体-标记压缩



缺点：

占用额外的内存空间





参数：

useG1

region的大小：2的幂

可控制的停顿时间





简化：

开启G1垃圾回收

设置最大内存

设置最大的停顿时间





三种回收模式：

youngGC

新生代的容量有限制，当达到这个限制的时候，触发youngGC,会触发stw，把eden区的内容放入到s区

为什么会触发stw呢？





younggc + Concrrent mark

初始标记，在younggc的时候就已经完成了

并发标记，什么时候触发（当老年代达到一定阈值，通过参数配置）





mixGC

fullGC



使用场景：

需要低延迟

服务器端，大内存





region的角色：

Eden，survivor，old,humongous



内部分配的方法：

指针碰撞







TLAB

单独给线程一小份

Thread Local Allocation Buffer



## ZGC

不随着内存增大而增加延迟

参数：
regionSize
停顿时间









//todoqifei

## 算法

三色标记

两个条件：
插入了一条从黑色到白色的引用
删除了全部从灰色到白色的引用

